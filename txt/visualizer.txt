# visualizer.py
"""
可视化模块
"""
import matplotlib.pyplot as plt
import numpy as np
import platform  # 导入 platform 模块用于检测操作系统

# --- 中文显示配置 ---
# 检查操作系统类型
system_name = platform.system()

try:
    if system_name == "Windows":
        # Windows 系统，尝试使用 'SimHei' (黑体) 或 'Microsoft YaHei' (微软雅黑)
        plt.rcParams['font.sans-serif'] = ['SimHei']
        print("[可视化配置] 检测到 Windows 系统，尝试设置字体为 SimHei")
    elif system_name == "Darwin":
        # macOS 系统，尝试使用 'Arial Unicode MS' 或 'PingFang SC'
        plt.rcParams['font.sans-serif'] = ['Arial Unicode MS']
        print("[可视化配置] 检测到 macOS 系统，尝试设置字体为 Arial Unicode MS")
    elif system_name == "Linux":
        # Linux 系统，需要确认安装了中文字体，例如 'WenQuanYi Micro Hei'
        # 可以通过命令 fc-list :lang=zh 查看已安装的中文字体
        # 如果 'WenQuanYi Micro Hei' 不可用，可以尝试其他已安装的字体
        plt.rcParams['font.sans-serif'] = ['WenQuanYi Micro Hei']
        print("[可视化配置] 检测到 Linux 系统，尝试设置字体为 WenQuanYi Micro Hei")
    else:
        print(f"[可视化配置] 未知的操作系统 ({system_name})，可能无法正确显示中文。")

    # 解决负号 '-' 显示为方块的问题
    plt.rcParams['axes.unicode_minus'] = False
    print("[可视化配置] 设置 axes.unicode_minus 为 False")

except Exception as e:
    print(f"[可视化配置] 设置字体时发生错误: {e}")
    print("[可视化配置] 请确保系统中已安装所选的中文字体。")


# --- 中文显示配置结束 ---


def plot_results(time_axis, original_signal, filtered_signal,
                 frequencies, power_spectrum,
                 peak_indices=None, detected_peak_frequencies=None,
                 base_freq_actual=None):
    """
    绘制双子图显示信号处理结果。

    参数:
    time_axis (numpy.ndarray): 时间轴。
    original_signal (numpy.ndarray): 原始信号。
    filtered_signal (numpy.ndarray): 滤波后信号。
    frequencies (numpy.ndarray): 功率谱的频率轴。
    power_spectrum (numpy.ndarray): 功率谱数据。
    peak_indices (list, optional): 检测到的峰值在功率谱中的索引。
    detected_peak_frequencies (list, optional): 检测到的峰值频率。
    base_freq_actual (float, optional): 原始信号的基频，用于在频谱图标注。
    """
    plt.figure(figsize=(12, 10))

    # 子图1: 原始信号与滤波后信号的时域对比
    plt.subplot(2, 1, 1)
    plt.plot(time_axis, original_signal, label='原始信号', alpha=0.7)
    plt.plot(time_axis, filtered_signal, label='滤波后信号', color='orange')
    plt.title('信号时域对比')  # 中文标题
    plt.xlabel('时间 (秒)')  # 中文标签
    plt.ylabel('幅值')  # 中文标签
    plt.legend()
    plt.grid(True)

    # 子图2: 功率谱图 (标注检测到的峰值点)
    plt.subplot(2, 1, 2)
    plt.plot(frequencies, power_spectrum, label='滤波后信号的功率谱')  # 中文图例

    if peak_indices and detected_peak_frequencies:
        # 确保 peak_indices 是 numpy 数组以便进行索引
        peak_indices_arr = np.array(peak_indices, dtype=int)
        # 检查索引是否在 power_spectrum 的有效范围内
        valid_indices = peak_indices_arr[peak_indices_arr < len(power_spectrum)]

        if len(valid_indices) > 0:
            # 使用有效索引进行绘图和标注
            valid_freqs = frequencies[valid_indices]
            valid_powers = power_spectrum[valid_indices]

            plt.scatter(valid_freqs, valid_powers,
                        color='red', marker='o', s=80, label='检测到的峰值')  # 中文图例

            # 标注时也使用有效索引对应的频率值
            # 注意：detected_peak_frequencies 列表需要与 valid_indices 对应
            # 一个更安全的方式是直接从 valid_indices 对应的 frequencies 取值来标注
            for idx in valid_indices:
                plt.annotate(f'{frequencies[idx]:.2f} Hz',  # 使用索引对应的频率
                             (frequencies[idx], power_spectrum[idx]),
                             textcoords="offset points",
                             xytext=(0, 10),
                             ha='center', color='red')

    if base_freq_actual is not None:
        plt.axvline(base_freq_actual, color='green', linestyle='--', alpha=0.6,
                    label=f'原始基频 ({base_freq_actual} Hz)')  # 中文图例

    plt.title('功率谱分析与峰值检测')  # 中文标题
    plt.xlabel('频率 (Hz)')  # 中文标签
    plt.ylabel('功率')  # 中文标签
    if len(frequencies) > 0:
        nyquist_freq = frequencies[-1]
        # 稍微调整X轴范围，使其更通用，例如显示到奈奎斯特频率或基频的10倍（取较小者）
        xlim_upper = nyquist_freq
        if base_freq_actual is not None:
            xlim_upper = min(nyquist_freq, base_freq_actual * 10)
        # 避免 xlim 设置为 (0, 0) 如果频率范围很小
        if xlim_upper <= 0:
            xlim_upper = nyquist_freq if nyquist_freq > 0 else 10  # 默认上限
        plt.xlim(0, xlim_upper)
    plt.ylim(bottom=0)  # 功率不会是负数
    plt.legend()
    plt.grid(True)

    plt.tight_layout()  # 调整子图布局，防止重叠
    plt.show()


if __name__ == '__main__':
    # 测试可视化模块 (使用中文标签)
    print("\n--- 可视化模块独立测试 ---")
    # 生成一些模拟数据
    fs_viz = 100
    t_viz = np.linspace(0, 10, 10 * fs_viz, endpoint=False)
    sig_orig_viz = np.sin(2 * np.pi * 5 * t_viz) + 0.5 * np.random.randn(len(t_viz))
    sig_filt_viz = np.sin(2 * np.pi * 5 * t_viz)  # 理想滤波

    # 使用 rfft 和 rfftfreq 计算单边谱
    yf_viz = np.fft.rfft(sig_filt_viz)
    freqs_viz = np.fft.rfftfreq(len(sig_filt_viz), 1 / fs_viz)

    # 计算功率谱 (简化版，仅用于测试可视化)
    # 幅度谱归一化
    N_viz = len(sig_filt_viz)
    amp_spec_viz = np.abs(yf_viz) / N_viz
    # 非直流和奈奎斯特分量乘以2
    if N_viz % 2 == 0:  # N is even
        amp_spec_viz[1:-1] *= 2
    else:  # N is odd
        amp_spec_viz[1:] *= 2
    powers_viz = amp_spec_viz ** 2

    # 找到最接近5Hz的峰值索引
    peak_idx_viz = np.argmax(powers_viz)  # 假设最大值就是我们要找的峰
    # peak_idx_viz = np.argmin(np.abs(freqs_viz - 5.0)) # 或者直接找5Hz

    detected_indices_viz = [peak_idx_viz]
    detected_freqs_viz = [round(freqs_viz[peak_idx_viz], 2)]  # 使用实际频率

    print(f"模拟数据: 基频=5Hz, 采样率={fs_viz}Hz")
    print(f"模拟检测到的峰值索引: {detected_indices_viz}")
    print(f"模拟检测到的峰值频率: {detected_freqs_viz}")

    # 调用绘图函数
    plot_results(t_viz, sig_orig_viz, sig_filt_viz,
                 freqs_viz, powers_viz,
                 detected_indices_viz, detected_freqs_viz,
                 base_freq_actual=5.0)

    print("--- 可视化模块测试结束 ---")