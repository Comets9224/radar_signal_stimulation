# filters.py
"""
滤波器模块
"""
from scipy.signal import butter, filtfilt
import numpy as np

def butter_bandpass(lowcut, highcut, fs, order=5):
    """
    设计Butterworth带通滤波器的系数。

    参数:
    lowcut (float): 低截止频率 (Hz)。
    highcut (float): 高截止频率 (Hz)。
    fs (float): 采样频率 (Hz)。
    order (int): 滤波器阶数。

    返回:
    tuple: (b, a) 滤波器的分子和分母多项式系数。
    """
    nyq = 0.5 * fs  # 奈奎斯特频率
    low = lowcut / nyq
    high = highcut / nyq
    # scipy.signal.butter 的 w_n 参数：
    # 对于带通滤波器，是 [low, high] 形式的归一化频率
    b, a = butter(order, [low, high], btype='band')
    return b, a

def butter_bandpass_filter(data, lowcut, highcut, fs, order=5):
    """
    对数据应用Butterworth带通滤波器（零相位）。

    参数:
    data (numpy.ndarray): 要滤波的输入信号。
    lowcut (float): 低截止频率 (Hz)。
    highcut (float): 高截止频率 (Hz)。
    fs (float): 采样频率 (Hz)。
    order (int): 滤波器阶数。

    返回:
    numpy.ndarray: 滤波后的信号。
    """
    b, a = butter_bandpass(lowcut, highcut, fs, order=order)
    y = filtfilt(b, a, data) # 使用零相位滤波
    return y

if __name__ == '__main__':
    # 测试滤波器模块
    import matplotlib.pyplot as plt
    from scipy.signal import freqz

    # 滤波器参数 (与实验要求一致)
    FS_FILTER = 1000  # Hz
    LOWCUT_FILTER = 4.0  # Hz
    HIGHCUT_FILTER = 6.0  # Hz
    ORDER_FILTER = 5

    # 计算滤波器系数
    b, a = butter_bandpass(LOWCUT_FILTER, HIGHCUT_FILTER, FS_FILTER, order=ORDER_FILTER)

    # 计算频率响应
    w, h = freqz(b, a, worN=8000) # worN是计算频率响应的点数

    plt.figure(figsize=(10, 6))
    plt.plot((FS_FILTER * 0.5 / np.pi) * w, abs(h), label="order = %d" % ORDER_FILTER)
    plt.plot([0, 0.5 * FS_FILTER], [np.sqrt(0.5), np.sqrt(0.5)], '--', label='sqrt(0.5)') # -3dB 点
    plt.axvline(LOWCUT_FILTER, color='green', linestyle='--', label=f'Lowcut ({LOWCUT_FILTER} Hz)')
    plt.axvline(HIGHCUT_FILTER, color='red', linestyle='--', label=f'Highcut ({HIGHCUT_FILTER} Hz)')
    plt.xlabel('频率 (Hz)')
    plt.ylabel('增益')
    plt.title('Butterworth 带通滤波器频率响应')
    plt.legend()
    plt.grid(True)
    plt.xlim(0, 15) # 关注通带附近
    plt.ylim(0, 1.1)
    plt.show()

    # 测试滤波效果 (可选，用一个简单信号)
    # t_test = np.linspace(0, 1, FS_FILTER, endpoint=False)
    # signal_test = (np.sin(2 * np.pi * 3 * t_test) +      # 在阻带
    #                np.sin(2 * np.pi * 5 * t_test) +      # 在通带
    #                np.sin(2 * np.pi * 7 * t_test))     # 在阻带
    # filtered_test = butter_bandpass_filter(signal_test, LOWCUT_FILTER, HIGHCUT_FILTER, FS_FILTER, order=ORDER_FILTER)

    # plt.figure(figsize=(12, 6))
    # plt.subplot(2,1,1)
    # plt.plot(t_test, signal_test, label='原始测试信号')
    # plt.title('滤波前测试信号')
    # plt.grid(True)
    # plt.legend()
    # plt.subplot(2,1,2)
    # plt.plot(t_test, filtered_test, label='滤波后测试信号')
    # plt.title('滤波后测试信号')
    # plt.xlabel('时间 (s)')
    # plt.grid(True)
    # plt.legend()
    # plt.tight_layout()
    # plt.show()