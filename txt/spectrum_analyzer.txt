# spectrum_analyzer.py
"""
频谱分析模块
"""
import numpy as np
from scipy.fft import fft, fftfreq


def compute_power_spectrum(signal, fs):
    """
    计算信号的功率谱。

    参数:
    signal (numpy.ndarray): 输入信号。
    fs (float): 采样频率 (Hz)。

    返回:
    tuple: (frequencies, power_spectrum)
        frequencies (numpy.ndarray): 频率轴 (0 到 Nyquist频率)。
        power_spectrum (numpy.ndarray): 对应的功率谱值。
    """
    N = len(signal)  # 信号长度

    # 执行FFT
    yf = fft(signal)

    # 计算频率轴 (对于fft的结果)
    # fftfreq 返回的是 [-fs/2, fs/2) 的频率，我们需要调整顺序或只取正半轴
    xf = fftfreq(N, 1 / fs)

    # 归一化处理 (功率谱通常是对幅值平方后归一化)
    # 幅度谱: 2.0/N * np.abs(yf) (乘以2是因为只看正半轴，直流和奈奎斯特频率除外)
    # 功率谱: (np.abs(yf)/N)**2  或者 (2.0/N * np.abs(yf))**2 / 2 (Parseval定理)
    # 这里采用直接对FFT结果的模平方，然后根据信号长度N进行归一化
    # 对于单边谱，通常乘以2 (除了DC和Nyquist)，但这里先计算双边功率谱，再取一半

    # 计算功率谱密度 (PSD) 的一种方式： Pxx = np.abs(yf)**2 / (N * fs)
    # 另一种功率谱 (PS) 的方式： Px = np.abs(yf)**2 / N**2 (如果yf是fft(signal))
    # 或者，如果 yf_scaled = fft(signal)/N，则 Px = np.abs(yf_scaled)**2
    # 实验要求 "除以信号长度"，这通常指对FFT结果的幅值进行归一化，再平方
    # 即 (abs(fft(sig))/N)^2

    # 我们按 scipy.signal.periodogram 的方式来理解功率：
    # 功率 = |FFT(x)|^2 / N^2 (for one-sided, multiply by 2, except DC and Nyquist)
    # 或者，直接使用 |FFT(x)/N|^2

    # 让我们遵循 "执行归一化处理 (除以信号长度)" -> 对FFT结果的幅值进行归一化
    normalized_yf_abs = np.abs(yf) / N

    # 功率谱是幅度的平方
    power_spectrum_full = normalized_yf_abs ** 2

    # 仅返回有效半频谱 (0 - Nyquist频率)
    # 对于偶数N，正频率部分是 0 到 N/2
    # 对于奇数N，正频率部分是 0 到 (N-1)/2
    # fftfreq 生成的频率已经包含了正负频率，我们可以直接筛选

    positive_freq_indices = np.where(xf >= 0)
    frequencies_half = xf[positive_freq_indices]
    power_spectrum_half = power_spectrum_full[positive_freq_indices]

    # 对于单边谱，除了直流分量(0Hz)和奈奎斯特频率(如果存在且N为偶数)，其他频率点的功率需要乘以2
    # 以保持总功率不变。
    if N % 2 == 0:  # N is even
        # DC (index 0) and Nyquist (index N//2 in one-sided view) are not doubled
        power_spectrum_half[1:N // 2] *= 2
    else:  # N is odd
        # DC (index 0) is not doubled
        power_spectrum_half[1:] *= 2

    # 注意：实验要求中 "除以信号长度" 可能有多种解释。
    # 如果是指 scipy.signal.welch 或 periodogram 的 'power' scaling，
    # 它们通常是 |FFT|^2 / (fs * N) for PSD, or sum(|x|^2)/N for total power.
    # 如果是简单的幅值谱归一化再平方，就是上面的做法。
    # 我们这里采用的是：功率谱值 P = (amplitude_at_freq)^2。
    # Amplitude = |FFT(sig)/N| for DC, and 2*|FFT(sig)/N| for f > 0.
    # So, Power = (|FFT(sig)/N|)^2 for DC, and (2*|FFT(sig)/N|)^2 for f > 0.
    # 另一种更直接的方式是：
    # yf_abs = np.abs(yf[:N//2]) # 取单边FFT的幅值
    # yf_abs_scaled = yf_abs / N # 归一化
    # yf_abs_scaled[1:] *= 2 # 非直流分量乘以2 (如果N是偶数，奈奎斯特分量不需要乘2)
    # power_spectrum_half = yf_abs_scaled**2
    # freqs_half = xf[:N//2]
    #
    # 让我们简化并遵循一个常见定义：
    # 1. FFT
    # 2. 取前半部分 (0 to Nyquist)
    # 3. 计算幅值: np.abs()
    # 4. 归一化: 除以 N
    # 5. 修正幅值: 非DC和非Nyquist分量乘以2
    # 6. 计算功率: 幅值平方

    yf_half_abs = np.abs(yf[:N // 2 + 1])  # 取到奈奎斯特频率（包括）
    xf_half = xf[:N // 2 + 1]

    # 归一化幅值
    amp_spectrum = yf_half_abs / N

    # 对于非直流(索引0)和非奈奎斯特(如果N为偶数，索引为N//2)分量，乘以2
    if N % 2 == 0:  # N is even, Nyquist is at N//2
        amp_spectrum[1:N // 2] *= 2
    else:  # N is odd, no unique Nyquist point in this scheme
        amp_spectrum[1:] *= 2

    power_spectrum_final = amp_spectrum ** 2

    return xf_half, power_spectrum_final


if __name__ == '__main__':
    # 测试频谱分析模块
    import matplotlib.pyplot as plt

    # 测试参数
    FS_SPEC = 100  # Hz (假设，为了方便观察低频)
    T_SPEC = 10  # seconds
    N_SPEC = FS_SPEC * T_SPEC  # number of points

    t_spec = np.linspace(0, T_SPEC, N_SPEC, endpoint=False)
    # 创建一个包含5Hz和15Hz分量的信号
    signal_5hz = 2.0 * np.sin(2 * np.pi * 5 * t_spec)  # 幅值为2
    signal_15hz = 0.5 * np.sin(2 * np.pi * 15 * t_spec)  # 幅值为0.5
    test_signal = signal_5hz + signal_15hz + 0.2 * np.random.randn(N_SPEC)

    freqs, powers = compute_power_spectrum(test_signal, FS_SPEC)

    plt.figure(figsize=(10, 6))
    plt.plot(freqs, powers)
    plt.title('功率谱 (Spectrum Analyzer Test)')
    plt.xlabel('频率 (Hz)')
    plt.ylabel('功率')
    plt.grid(True)
    plt.xlim(0, FS_SPEC / 2)  # 显示到奈奎斯特频率
    # 理论上5Hz的功率应该是 (2.0)^2 / 2 = 2 (如果用RMS幅值定义) 或 (2.0)^2 = 4 (如果用峰值幅值定义)
    # 如果是 A*sin(wt), 功率谱峰值应为 (A^2)/2 (for one-sided spectrum if A is peak amplitude)
    # 或者，如果用我们定义的 amp_spectrum，其峰值应为 A。则 power_spectrum_final 峰值为 A^2。
    # 5Hz 处幅值为 2.0, 功率应接近 2.0^2 = 4.0
    # 15Hz 处幅值为 0.5, 功率应接近 0.5^2 = 0.25
    # 检查峰值：
    peak_5hz_idx = np.argmin(np.abs(freqs - 5))
    peak_15hz_idx = np.argmin(np.abs(freqs - 15))
    print(f"功率在 {freqs[peak_5hz_idx]:.2f} Hz 处: {powers[peak_5hz_idx]:.4f} (预期幅值2.0, 功率4.0)")
    print(f"功率在 {freqs[peak_15hz_idx]:.2f} Hz 处: {powers[peak_15hz_idx]:.4f} (预期幅值0.5, 功率0.25)")
    plt.show()