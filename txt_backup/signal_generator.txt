# signal_generator.py
"""
信号生成模块
"""
import numpy as np
import json # 用于保存和加载数据

# 函数定义保持不变
def generate_signal(duration=10, num_points=1000, base_freq=5, noise_mean=0, noise_std=0.5):
    time_axis = np.linspace(0, duration, num_points, endpoint=False)
    clean_signal = np.sin(2 * np.pi * base_freq * time_axis)
    noise = np.random.normal(noise_mean, noise_std, num_points)
    noisy_signal = clean_signal + noise
    fs_actual = num_points / duration
    return time_axis, noisy_signal, fs_actual

# --- 当这个脚本被直接运行时 ---
if __name__ == '__main__':
    import matplotlib.pyplot as plt
    import time

    print("\n--- 信号生成模块独立测试 (交互式多曲线对比模式 + 保存数据) ---")

    try:
        plt.rcParams['font.sans-serif'] = ['SimHei']
        plt.rcParams['axes.unicode_minus'] = False
        print("[模块一] 尝试设置字体为 SimHei")
    except Exception as e:
        print(f"[模块一] 设置字体 SimHei 失败: {e}")

    DURATION_SEC = 1.0
    NUM_SAMPLES = 1000
    print(f"将使用固定时长: {DURATION_SEC} 秒, 固定采样点数: {NUM_SAMPLES} 个 (FS={NUM_SAMPLES/DURATION_SEC}Hz)")

    time_axis_common = np.linspace(0, DURATION_SEC, NUM_SAMPLES, endpoint=False)
    fs_common = NUM_SAMPLES / DURATION_SEC

    plt.ion() # 开启交互模式，以便在循环中动态更新图形
    fig, ax = plt.subplots(figsize=(12, 6)) # 创建图形和坐标轴对象
    ax.set_title("生成的信号 (交互式添加)")
    ax.set_xlabel("时间 (秒)")
    ax.set_ylabel("幅值")
    ax.grid(True)

    signals_data_to_save = {
        "time_axis": time_axis_common.tolist(),
        "fs": fs_common,
        "signals": []
    }
    curve_count = 1
    keep_adding = True

    while keep_adding:
        print(f"\n--- 输入第 {curve_count} 条曲线的参数 ---")
        try:
            user_base_freq_str = input(f"基频 (Hz) [默认 5]: ")
            user_base_freq = float(user_base_freq_str) if user_base_freq_str else 5.0

            # 重新加入噪声均值的输入
            user_noise_mean_str = input(f"噪声均值 [默认 0]: ")
            user_noise_mean = float(user_noise_mean_str) if user_noise_mean_str else 0.0

            user_noise_std_str = input(f"噪声标准差 [默认 0.5]: ")
            user_noise_std = float(user_noise_std_str) if user_noise_std_str else 0.5
            if user_noise_std < 0: user_noise_std = 0.5; print("标准差不能为负,已设为0.5")

        except ValueError:
            print("输入无效，请使用数字。参数将使用默认值。")
            user_base_freq = 5.0
            user_noise_mean = 0.0 # 默认噪声均值
            user_noise_std = 0.5

        print(f"生成: 基频={user_base_freq}Hz, 噪声均值={user_noise_mean}, 噪声标准差={user_noise_std}")
        _, current_signal, _ = generate_signal(
            duration=DURATION_SEC,
            num_points=NUM_SAMPLES,
            base_freq=user_base_freq,
            noise_mean=user_noise_mean, # 使用用户输入的噪声均值
            noise_std=user_noise_std
        )

        label = f"F={user_base_freq}Hz, Mean={user_noise_mean}, Std={user_noise_std}" # 更新标签
        ax.plot(time_axis_common, current_signal, label=label, alpha=0.85)
        ax.legend() # 更新图例
        plt.draw() # 绘制当前图形
        plt.pause(0.1) # 短暂停顿以确保图形更新

        signals_data_to_save["signals"].append({
            "label": label,
            "base_freq": user_base_freq,
            "noise_mean": user_noise_mean, # 保存噪声均值
            "noise_std": user_noise_std,
            "data": current_signal.tolist()
        })

        add_another = input("是否添加下一条曲线? (y/n) [y]: ").lower()
        if add_another == 'n':
            keep_adding = False
        curve_count += 1

    output_filename = "signal_to_filters.txt"
    try:
        with open(output_filename, 'w') as f:
            json.dump(signals_data_to_save, f, indent=4)
        print(f"\n所有生成的信号数据已保存到 {output_filename}")
    except IOError as e:
        print(f"错误：无法写入文件 {output_filename}: {e}")
    except Exception as e:
        print(f"保存数据时发生未知错误: {e}")


    print("\n已结束添加曲线。")
    ax.set_title("生成的信号 (最终结果)") # 更新最终图形的标题
    plt.ioff() # 关闭交互模式，因为 plt.show() 会阻塞

    # --- 新增：定义按键事件处理函数 ---
    def close_all_figs_on_enter(event):
        """当在图形窗口上按下回车键时，关闭所有 matplotlib 窗口。"""
        if event.key == 'enter':
            plt.close('all') # 'all' 参数表示关闭所有打开的 figure
            print("检测到回车键，已关闭所有 Matplotlib 图形窗口。")

    # 将键盘按下事件连接到处理函数
    # 确保 fig 对象有效 (通常在此处是有效的)
    if 'fig' in locals() and hasattr(fig, 'canvas') and fig.canvas is not None:
        fig.canvas.mpl_connect('key_press_event', close_all_figs_on_enter)
        print("\n提示：当图形窗口显示并激活时，按 Enter 键可以关闭所有图形窗口。")
    else:
        print("警告：未能连接按键事件以关闭窗口，图形对象 'fig' 可能未正确初始化。")
    # --- 新增代码结束 ---

    plt.show() # 显示最终图形，并启动 Matplotlib 事件循环

    print(f"采样率: {fs_common:.2f} Hz")
    print("--- 模块一测试结束 ---")